<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>uncomplicate.fluokitten.test documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fluokitten</span> <span class="project-version">0.6.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fluokitten</span></div></div></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.jvm.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jvm</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-3 branch current"><a href="uncomplicate.fluokitten.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3"><a href="uncomplicate.fluokitten.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-applicative-law1"><div class="inner"><span>applicative-law1</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-applicative-law2-identity"><div class="inner"><span>applicative-law2-identity</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-applicative-law3-composition"><div class="inner"><span>applicative-law3-composition</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-applicative-law4-homomorphism"><div class="inner"><span>applicative-law4-homomorphism</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-applicative-law5-interchange"><div class="inner"><span>applicative-law5-interchange</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-check-eq"><div class="inner"><span>check-eq</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-data-structures-should-preserve-metadata"><div class="inner"><span>data-structures-should-preserve-metadata</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-fapply-keeps-type"><div class="inner"><span>fapply-keeps-type</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-fmap-keeps-type"><div class="inner"><span>fmap-keeps-type</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-functor-law2"><div class="inner"><span>functor-law2</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-magma-op-keeps-type"><div class="inner"><span>magma-op-keeps-type</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-monad-law1-left-identity"><div class="inner"><span>monad-law1-left-identity</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-monad-law2-right-identity"><div class="inner"><span>monad-law2-right-identity</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-monad-law3-associativity"><div class="inner"><span>monad-law3-associativity</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-monoid-identity-law"><div class="inner"><span>monoid-identity-law</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.test.html#var-semigroup-op-associativity"><div class="inner"><span>semigroup-op-associativity</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">uncomplicate.fluokitten.test</h1><div class="doc"><pre class="plaintext">Macros that generate Midje tests for various laws that
categorical concepts have to satisfy. You should use these tests
to check if your implementations of clojure protocols are valid
beyond what the compiler can assert.</pre></div><div class="public anchor" id="var-applicative-law1"><h3>applicative-law1</h3><h4 class="type">macro</h4><div class="usage"><code>(applicative-law1 f x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x
satisfies the first applicative law:

(fapply (pure x f) x) =&gt; (fmap f x)
</pre></div></div><div class="public anchor" id="var-applicative-law2-identity"><h3>applicative-law2-identity</h3><h4 class="type">macro</h4><div class="usage"><code>(applicative-law2-identity x)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x
satisfies the second applicative law:

(fapply (pure x identity) x) =&gt; x
</pre></div></div><div class="public anchor" id="var-applicative-law3-composition"><h3>applicative-law3-composition</h3><h4 class="type">macro</h4><div class="usage"><code>(applicative-law3-composition u v x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x
satisfies the third applicative law:

(&lt;*&gt; (pure x (curry comp)) u v x)
=&gt; (fapply u (fapply v x))
</pre></div></div><div class="public anchor" id="var-applicative-law4-homomorphism"><h3>applicative-law4-homomorphism</h3><h4 class="type">macro</h4><div class="usage"><code>(applicative-law4-homomorphism ap f x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x
satisfies the fourth applicative law:

(fapply (pure a f) (pure a x)) =&gt; (f x)
</pre></div></div><div class="public anchor" id="var-applicative-law5-interchange"><h3>applicative-law5-interchange</h3><h4 class="type">macro</h4><div class="usage"><code>(applicative-law5-interchange ap f x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x
satisfies the fifth applicative law:

(fapply u (pure a y)) =&gt; (fapply (pure a fn(% y)) u)
</pre></div></div><div class="public anchor" id="var-check-eq"><h3>check-eq</h3><div class="usage"><code>(check-eq expected)</code><code>(check-eq expected actual)</code></div><div class="doc"><pre class="plaintext">Midje checker that check for the equality of contents in contexts such
as references and reducibles.</pre></div></div><div class="public anchor" id="var-data-structures-should-preserve-metadata"><h3>data-structures-should-preserve-metadata</h3><h4 class="type">macro</h4><div class="usage"><code>(data-structures-should-preserve-metadata f1 f2 builder x y)</code></div><div class="doc"><pre class="plaintext">Generates the tests that check whether the implementations
of functions defined in Fluokitten protocols that extend
Clojure core data structures preserve metadata.</pre></div></div><div class="public anchor" id="var-fapply-keeps-type"><h3>fapply-keeps-type</h3><h4 class="type">macro</h4><div class="usage"><code>(fapply-keeps-type f x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the applicative functor x's
implementation of fapply keeps the type of x when the function
inside f is applied to its content.</pre></div></div><div class="public anchor" id="var-fmap-keeps-type"><h3>fmap-keeps-type</h3><h4 class="type">macro</h4><div class="usage"><code>(fmap-keeps-type f x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the functor x's implementation of
fmap keeps the type of x when f is applied to its content.</pre></div></div><div class="public anchor" id="var-functor-law2"><h3>functor-law2</h3><h4 class="type">macro</h4><div class="usage"><code>(functor-law2 f x)</code><code>(functor-law2 f g x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the functor x satisfies
the Second Functor Law:

(fmap (comp f g)) =&gt; (fmap f (fmap g))

or, when applied to a concrete functor:

(fmap (comp f g) x) =&gt; (fmap f (fmap g x))
</pre></div></div><div class="public anchor" id="var-magma-op-keeps-type"><h3>magma-op-keeps-type</h3><h4 class="type">macro</h4><div class="usage"><code>(magma-op-keeps-type x y &amp; ys)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the operation op is closed on magma x.
</pre></div></div><div class="public anchor" id="var-monad-law1-left-identity"><h3>monad-law1-left-identity</h3><h4 class="type">macro</h4><div class="usage"><code>(monad-law1-left-identity m g x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the monad x
satisfies the first monad law:

(bind (pure m x) f) =&gt; (g x)
</pre></div></div><div class="public anchor" id="var-monad-law2-right-identity"><h3>monad-law2-right-identity</h3><h4 class="type">macro</h4><div class="usage"><code>(monad-law2-right-identity m)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the monad x
satisfies the secondmonad law:

(bind m (pure m)) =&gt; m
</pre></div></div><div class="public anchor" id="var-monad-law3-associativity"><h3>monad-law3-associativity</h3><h4 class="type">macro</h4><div class="usage"><code>(monad-law3-associativity f g m &amp; ms)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if the monad x
satisfies the third monad law:

(bind m (fn [x] (bind (f x) g)
</pre></div></div><div class="public anchor" id="var-monoid-identity-law"><h3>monoid-identity-law</h3><h4 class="type">macro</h4><div class="usage"><code>(monoid-identity-law x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks whether the Monoid implementation x
satisfies the monoid identity law, i.e. if identity element for op
exists:
   (op x (id x)) =&gt; x
   (op (id x) x) =&gt; x
</pre></div></div><div class="public anchor" id="var-semigroup-op-associativity"><h3>semigroup-op-associativity</h3><h4 class="type">macro</h4><div class="usage"><code>(semigroup-op-associativity x y &amp; ys)</code></div><div class="doc"><pre class="plaintext">Generates a test that checks if x and op form a semigroup,
i.e whether op is associative:

(op (op a b)) =&gt; (op a (op b c))
</pre></div></div></div></body></html>