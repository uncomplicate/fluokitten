<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>uncomplicate.fluokitten.protocols documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fluokitten</span> <span class="project-version">0.6.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fluokitten</span></div></div></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.jvm.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jvm</span></div></a></li><li class="depth-3 branch current"><a href="uncomplicate.fluokitten.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.fluokitten.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3"><a href="uncomplicate.fluokitten.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Applicative"><div class="inner"><span>Applicative</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-fapply"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fapply</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-pure"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pure</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Curry"><div class="inner"><span>Curry</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-arity"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>arity</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-curry"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>curry</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-uncurry"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncurry</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Foldable"><div class="inner"><span>Foldable</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-fold"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fold</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-foldmap"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>foldmap</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Functor"><div class="inner"><span>Functor</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-fmap"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fmap</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Magma"><div class="inner"><span>Magma</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-op"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>op</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Maybe"><div class="inner"><span>Maybe</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-value"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>value</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Monad"><div class="inner"><span>Monad</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-bind"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bind</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-join"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-Monoid"><div class="inner"><span>Monoid</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-id"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>id</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-PseudoApplicative"><div class="inner"><span>PseudoApplicative</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-fapply.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fapply!</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-PseudoFunctor"><div class="inner"><span>PseudoFunctor</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-fmap.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fmap!</span></div></a></li><li class="depth-1"><a href="uncomplicate.fluokitten.protocols.html#var-PseudoMonad"><div class="inner"><span>PseudoMonad</span></div></a></li><li class="depth-2 branch"><a href="uncomplicate.fluokitten.protocols.html#var-bind.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bind!</span></div></a></li><li class="depth-2"><a href="uncomplicate.fluokitten.protocols.html#var-join.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">uncomplicate.fluokitten.protocols</h1><div class="doc"><pre class="plaintext">Defines Fluokitten protocols for various categorical concepts.
You need to use or require this namespace and provide your implementations
of these protocols if you want to extend Fluokitten with specific instances
of categorical concepts beyond those from Clojure core that Fluokitten
itself extends to be categorical. To use your own implementations, you need
to use or require the namespace where you define the implementations
from the calling code's namespace, as well as to use or require Fluokitten
core. Your implementations are normally not called directly from the client
code. The client code should call the generic functions from Fluokitten core.</pre></div><div class="public anchor" id="var-Applicative"><h3>Applicative</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Applicative (applicative functor) is an abstraction for a
context (box, container, computation) along with the abiliity
to apply function(s) contained in the same type of context to
all the things inside that context. Every Applicative should
also implement Functor, although it can not be automatically
forced by Clojure protocols.

A typical example is a clojure sequence, wich is a container
of elements, with the ability to apply all the functions
contained in another sequence to each of the elements,
wich produces a new sequence of elements transformed by
all the functions.

You create a new applicative functor type by extending
the Applicative protocol and implementing pure and fapply
methods, while observing applicative functor laws:

1. (fapply (pure x f) x) =&gt; (fmap f x)

2. Identity Law: (fapply (pure x identity) x) =&gt; x

3. Composition Law:
   (fapply (fapply (fapply (pure x (curry comp)) u) v) x)
   =&gt; (fapply u (fapply v x))

4. Homomorphism Law: (fapply (pure a f) (pure a x)) =&gt; (f x)

5. Interchange Law:
   (fapply u (pure a y)) =&gt; (fapply (pure a #(% y)) u)

Fluokitten's test library contains macros that generate
tests for applicative functor laws.

The pure and fapply methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fapply"><h3>fapply</h3><div class="usage"><code>(fapply av ag)</code><code>(fapply av ag avs)</code></div><div class="doc"><pre class="plaintext">Applies the function(s) inside ag's context to the value(s)
inside av's context while preserving the context. Both contexts
should be of the same (or compatible) type, and the type of
the resulting context is determined by av's type.
If more applicative functor values are supplied in a
sequence avs, uses them as arguments for vararg
function(s) inside the context ag.
This method is intended to be used by fluokitten core's
fapply, not directly by clients. The third argument, avs,
contains a sequence of all additional arguments, normally
supplied by core fapply's varargs (protocol methods do not
support varargs).</pre></div></div><div class="public anchor" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure av v)</code><code>(pure av v vs)</code></div><div class="doc"><pre class="plaintext">Takes any context av and any value a, and puts
the value a in the same type of context. a should be put
in the most minimal context possible that has appropriate
type. av is needed only for proper dispatching and is
not changed in any way.</pre></div></div></div></div></div><div class="public anchor" id="var-Curry"><h3>Curry</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-arity"><h3>arity</h3><div class="usage"><code>(arity f)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-curry"><h3>curry</h3><div class="usage"><code>(curry f)</code><code>(curry f arity)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-uncurry"><h3>uncurry</h3><div class="usage"><code>(uncurry f)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-Foldable"><h3>Foldable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Foldable is an abstraction for a context (box, container,
computation) along with the ability to extract the summary
value of its contents. Foldable implementations  do not
have to implement other categorical protocols, although
it is convenient to view fold as an opposite of the function
pure: pure puts values in minimal context, while fold
gets the value outside of the context. With some Foldables,
(such as Atom) context contains a single value that can be
accessed by fold, while some (such as PersistentColection)
contain many values, so they can only extract it as some
summary value.

You create a new foldable type by extending the Foldable
protocol and implementing fold and foldmap methods.

The fold and foldmap methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold x)</code><code>(fold x f init)</code><code>(fold x f init y)</code><code>(fold x f init y z)</code><code>(fold x f init y z w)</code><code>(fold x f init y z w ws)</code></div><div class="doc"><pre class="plaintext">Extracts the value(s) from the context and returns it
as one single value. Contexts that contain multiple values
typically require that values are Monoids and use op
to combine them.</pre></div></div><div class="public anchor" id="var-foldmap"><h3>foldmap</h3><div class="usage"><code>(foldmap x g)</code><code>(foldmap x g f init)</code><code>(foldmap x g f init y)</code><code>(foldmap x g f init y z)</code><code>(foldmap x g f init y z w)</code><code>(foldmap x g f init y z w ws)</code></div><div class="doc"><pre class="plaintext">Similar to fold, but before returning the sole value
from the context or combining multiple values into
a summary, applies the function g to transform it
(to a Monoid if needed).</pre></div></div></div></div></div><div class="public anchor" id="var-Functor"><h3>Functor</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Functor is an abstraction for a context (box, container,
computation) along with the abiliity to apply a function
to all the things inside that context. A typical example
is a clojure sequence, wich is a container of elements,
with the ability to apply a function to each of the elements,
wich produces a new sequence of elements transformed by
that function.

You create a new functor type by extending the Functor
protocol and implementing fmap method, while observing
functor laws:

1. (fmap identity) =&gt; identity ,
   that is (fmap identity x) =&gt; (identity x)

2. (fmap (comp f g)) =&gt; (fmap f (fmap g))
   or, when applied to a concrete functor
   (fmap (comp f g) x) =&gt; (fmap f (fmap g x))

(please note that core's fmap that has a different
order of arguments has been used in these examples,
as it would be used by clients)

Fluokitten's test library contains macros that generate
tests for functor laws.

The fmap method is not intended to be used directly by
the caller, although you should use it directly from
the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap fv g)</code><code>(fmap fv g fvs)</code></div><div class="doc"><pre class="plaintext">Applies function g to the value(s) inside the context
of the functor fv. The result is a functor of the same
type as fv. If more functor values are supplied in a
sequence fvs, uses them as arguments for a vararg g.
This method is intended to be used by fluokitten core's
fmap, not directly by clients. The first two arguments
are reversed compared to core's fmap because protocol's
polymorphism is based on java-based dispatch. The third
parameter, fvs, contains a sequence of all additional
arguments, normally supplied by core fmap's varargs
(protocol methods do not support varargs).</pre></div></div></div></div></div><div class="public anchor" id="var-Magma"><h3>Magma</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Magma is an abstraction of elements that have an operation op,
which combines its arguments into an element of the same
type (op is closed on the set of all objects that have that type).
If the operation op is also associative, then that magma
is also a semigroup.

You create a new magma type by extending the Magma protocol
and implementing op method while observing the following laws:

1. closed: (instance? (type x) ((op x) x y)) =&gt; true

2. associativity (only for semigroups):
   (let [f (op a)]
     (f (f a b) c) =&gt; (f a (f b c)))


Fluokitten's test library contains macros that generate
tests for checking whether op is closed and/or associative.

The op method is not intended to be used
directly by the caller, although you should use it directly
from the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-op"><h3>op</h3><div class="usage"><code>(op x)</code></div><div class="doc"><pre class="plaintext">Returns the function (operation) that combines elements x and y
(and optionally z, w, ...) into an element of the same type.
When that function is called with no arguments, it should return
the id element of the monoid (if the magma is also a Monoid).
</pre></div></div></div></div></div><div class="public anchor" id="var-Maybe"><h3>Maybe</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-value"><h3>value</h3><div class="usage"><code>(value m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-Monad"><h3>Monad</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Monad is an abstraction for a context (box, container,
computation) along with the ability to apply a function
that accepts the value without the context and produces
the result in a context. The resulting context may be
different than the starting context. While the main idea
with functors and applicatives is modifying the values
inside the context, monad is more oriented towards modifying
the context.  Every Monad should also implement
Applicative and Functor protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monad type by extending the Monad protocol
and implementing bind and join methods, while observing
monad laws:

1. Left Identity Law: (bind (pure m x) f) =&gt; (g x)

2. Right Identity Law: (bind m (pure m)) =&gt; m

3. Associativity Law:
   (bind (bind m f) g) =&gt; (bind m (fn [x] (bind (f x) g)

Fluokitten's test library contains macros that generate
tests for monad laws.

The bind and join methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind mv g)</code><code>(bind mv g mvs)</code></div><div class="doc"><pre class="plaintext">Applies the function g to the value(s) inside mv's context.
Function g produces the result inside with the context,
in contrast to fmap where function g is expect to produce
normal values. If more monadic values are supplied in a
sequence mvs, uses them as arguments for a vararg g.
This method is intended to be used by fluokitten core's
bind, not directly by clients. The third argument, mvs,
contains a sequence of all additional arguments, normally
supplied by core bind's varargs (protocol methods do not
support varargs).
</pre></div></div><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join mv)</code></div><div class="doc"><pre class="plaintext">Flattens multiple monads nested in monadic into a single
flat monad that contains ordinary, non-monadic value.</pre></div></div></div></div></div><div class="public anchor" id="var-Monoid"><h3>Monoid</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Monoid is an abstraction of elements that are magmas whose
op has an identity element. (op x (id x)) =&gt; x. Every Monoid
should also implement Magma protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monoid type by extending the Monoid protocol
and implementing id method, while observing monoid law:

1. identity element for op exists:
   (op x (id x)) =&gt; x
   (op (id x) x) =&gt; x

Fluokitten's test library contains macros that generate
monoid tests.

The id method is not intended to be used
directly by the caller, although you should use it directly
from the implementation of this protocol if needed from
other methods.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-id"><h3>id</h3><div class="usage"><code>(id m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-PseudoApplicative"><h3>PseudoApplicative</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A variant of Applicative that may be changed during the fapply!.
In a puritan sense, it is not an applicative functor, but it behaves in
an analog way. Typical use case is fapply-ing a Java array and overwriting
each element with the result of g.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fapply.21"><h3>fapply!</h3><div class="usage"><code>(fapply! av ag)</code><code>(fapply! av ag avs)</code></div><div class="doc"><pre class="plaintext">An impure version of fapply.
</pre></div></div></div></div></div><div class="public anchor" id="var-PseudoFunctor"><h3>PseudoFunctor</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A variant of Functor that may be changed during the fmap!.
In a puritan sense, it is not a functor, but it behaves in
the analog way as proper functors. Typical use case is
fmapping a primitive array and overwriting each element with
the result of f.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fmap.21"><h3>fmap!</h3><div class="usage"><code>(fmap! x f)</code><code>(fmap! x f y)</code><code>(fmap! x f y z)</code><code>(fmap! x f y z v)</code><code>(fmap! x f y z v ws)</code></div><div class="doc"><pre class="plaintext">Impure version of Functor's fmap.
</pre></div></div></div></div></div><div class="public anchor" id="var-PseudoMonad"><h3>PseudoMonad</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A dirty heretic cousin of Monad that may be changed during the bind! or join!
In a puritan sense, it is not a monad , but it behaves in an analog way.
Typical use case is binding a Java array and overwriting each
element with the result of g.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-bind.21"><h3>bind!</h3><div class="usage"><code>(bind! mv g)</code><code>(bind! mv g mvs)</code></div><div class="doc"><pre class="plaintext">Impure variant of bind.
</pre></div></div><div class="public anchor" id="var-join.21"><h3>join!</h3><div class="usage"><code>(join! mv)</code></div><div class="doc"><pre class="plaintext">Impure variant of join.
</pre></div></div></div></div></div></div></body></html>